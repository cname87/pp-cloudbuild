# Cloud Build...
# 1. Copies the source project files & directories excluding those directories listed in .gcloudignore.  (Note that when running gcloud locally it appears to ignore .gcloudignore).
# 2. Each step builds an image and runs an associated container with the copied source files mounted at /workspace.
# Changes made to the /workspace directory are persisted between each build step.
# Note: Define the working directory of the container in each step using a relative path, which will be relative to /workspace, i.e. relative to the project source files. (If you set 'dir: /' the working directory would be the root of the container which is typically not what you want).

# To run...
# Run 'gcloud builds submit --config cloudbuild.yaml' from the project root to trigger a cloud build.
# Run 'cloud-build-local --dryrun=false .' to trigger a local build.
# A build can also be triggered by a change in a github repo (if so configured).

steps:

 # When a build is executed from GCP via a github trigger the secret files, and associated directories, are not in git so you must download them from GCP Storage.  The directory structure of the GCP storage bucket MUST be set up to match the directory structure of the missing files & directories, as a recursive copy is carried out to copy the directory structure and files.
 # Note: This step is superfluous when triggered via CLI.
- id: 'download environment and certs files'
# Copy the backend .env, frontend e2e .env, database certs, & GCP Storage key files from GCP Storage to the persisted workspace.
  name: 'gcr.io/cloud-builders/gsutil'
  dir: '.'
  args: [
    # Run operations in parallel
    '-m',
    # Copy recursively
    'cp', '-r',
    # Don't overwrite
    '-n',
    'gs://project-perform-gcp-environment-files/*',
    '.',
  ]

# - id: 'install backend node_modules'
# # Install the backend node_modules directory in the persisted workspace.
# # Note: Using the node-with-puppeteer image (rather than a simple node image) as it is needed in other steps (which means only 1 image download) is required.
#   name: 'gcr.io/$PROJECT_ID/node-with-puppeteer'
#   entrypoint: npm
#   dir: './backend'
#   args: ['install']

# - id: 'install frontend node_modules'
# # Install the backend node_modules directory in the persisted workspace.
#   name: 'gcr.io/$PROJECT_ID/node-with-puppeteer'
#   entrypoint: npm
#   dir: './frontend'
#   args: ['install']

# - id: 'build backend'
# # Build the backend in the persisted workspace (replacing the copied in dist files - the built files are later deployed).
#   name: 'gcr.io/$PROJECT_ID/node-with-puppeteer'
#   entrypoint: npm
#   dir: './backend'
#   args: ['run', 'build']

# - id: 'build frontend'
# # Build the frontend in the persisted workspace (replacing the copied in dist files - the built files are deployed).
#   name: 'gcr.io/$PROJECT_ID/node-with-puppeteer'
#   entrypoint: npm
#   dir: './frontend'
#   args: ['run', 'build:prod']

# - id: 'unit test backend'
# # Run all backend unit tests.
# # Must use the image built above that includes Node & Puppeteer.
#   name: 'gcr.io/$PROJECT_ID/node-with-puppeteer'
#   dir: './backend'
#   env: ['NODE_ENV=staging']
#   args: ['npm', 'run', 'test']

# - id: 'unit test frontend'
# # Run all frontend unit tests.
# # Must use the image built above that includes Node & Puppeteer.
#   name: 'gcr.io/$PROJECT_ID/node-with-puppeteer'
#   dir: './frontend'
#   args: ['npm', 'run', 'test:staging']

# - id: 'Build backend server image'
# # Build the backend server image (which is later deployed).
#   name: 'gcr.io/cloud-builders/docker'
#   dir: './backend'
#   args: [
#     'build',
#     '--file='Dockerfile',
#     '--tag=${_BACKEND_IMAGE}:${_BACKEND_VERSION}',
#     '.']

# - id: 'Push backend server image'
# # Push the backend server image so can be pulled for deployment.
#   name: 'gcr.io/cloud-builders/docker'
#   args: [
#     'push',
#     '${_BACKEND_IMAGE}:${_BACKEND_VERSION}',
#   ]

# - id: 'Build frontend server image'
# # Build the frontend server image (which is later deployed).
#   name: 'gcr.io/cloud-builders/docker'
#   dir: './frontend'
#   args: [
#     'build',
#     '--file=Dockerfile',
#     '-t=${_FRONTEND_IMAGE}:${_FRONTEND_VERSION}',
#     '.',
#   ]

# - id: 'Push frontend server image'
# # Push the backend server image (which is later deployed).
#   name: 'gcr.io/cloud-builders/docker'
#   args: [
#     'push',
#     '${_FRONTEND_IMAGE}:${_FRONTEND_VERSION}',
#   ]

# - id: 'Run backend server'
# # Run the backend server in the background.
#   name: 'gcr.io/cloud-builders/docker'
#   dir: './backend'
#   args: [
#     'run',
#     # The name matches the proxy set up in the e2e configuration.
#     '--name=backend',
#     # Remove container when stopped.
#     '--rm',
#     # Run detached.
#     '-d=true',
#     '-p=8080:8080',
#     # Attach to the local Docker network named cloudbuild to which the container in each build step is attached.
#     '--network=cloudbuild',
#     # Run with NODE_ENV=staging => TEST_PATHS available.
#     '--env', 'NODE_ENV=staging',
#     # Runs the image built in a previous build step.
#     '${_BACKEND_IMAGE}:${_BACKEND_VERSION}'
#   ]

# - id: 'Run e2e test in staging environment'
# # Runs an e2e test against the built backend server.
# # Runs a local frontend server serving the built frontend.
# # Pre-compiles using a staging environment file that enables error and cache interceptors in the frontend.
# # Runs Protractor using a staging configuration that runs the cache or errors tests.
# # BASE_URL is set to run against the server running in the backend.
# # The configured test user has access to the test database.
# # The staging environment file selected by NODE_ENV=staging sets the backend server to be run with test paths available.  It also sets that the test database is in use.
#   name: 'gcr.io/$PROJECT_ID/node-with-puppeteer'
#   dir: './frontend'
#   args: ['npm', 'run', 'e2e:staging']

# - id: 'Stop backend server'
# # Stops the backend server running in the background.
#   name: 'gcr.io/cloud-builders/docker'
#   dir: './backend'
#   args: [
#     'container', 'stop',
#     'backend',
#   ]

- id: 'Prepare configuration for deployment'
  name: 'gcr.io/cloud-builders/gke-deploy'
  dir: './backend'
  args: [
  'prepare',
  '--filename=certs',
  '--app=$_K8S_APP_NAME',
  '--namespace=$_K8S_NAMESPACE',
  '--output=$_OUTPUT_PATH/certs/',
  '--annotation=gcb-build-id=$BUILD_ID',
  ]

- id: 'Deploy configuration'
  name: 'gcr.io/cloud-builders/gke-deploy'
  dir: './backend'
  args: [
  'apply',
  '--filename=$_OUTPUT_PATH/certs/expanded/*',
  '--namespace=$_K8S_NAMESPACE',
  '--cluster=$_GKE_CLUSTER',
  '--location=$_GKE_ZONE',
  ]

- id: 'Prepare ingress for deployment'
  name: 'gcr.io/cloud-builders/gke-deploy'
  dir: './'
  args: [
  'prepare',
  '--filename=ingress',
  '--app=$_K8S_APP_NAME',
  '--namespace=$_K8S_NAMESPACE',
  '--output=$_OUTPUT_PATH/ingress/',
  '--annotation=gcb-build-id=$BUILD_ID',
  ]

- id: 'Deploy ingress'
  name: 'gcr.io/cloud-builders/gke-deploy'
  dir: './'
  args: [
  'apply',
  '--filename=$_OUTPUT_PATH/ingress/expanded/*',
  '--namespace=$_K8S_NAMESPACE',
  '--cluster=$_GKE_CLUSTER',
  '--location=$_GKE_ZONE',
  ]

- id: 'Prepare backend for deployment'
  name: 'gcr.io/cloud-builders/gke-deploy'
  dir: './'
  args: [
  'prepare',
  '--filename=backend/kubernetes-manifests',
  '--image=${_BACKEND_IMAGE}:${_BACKEND_VERSION}',
  '--app=$_K8S_APP_NAME',
  '--version=$_BACKEND_VERSION',
  '--namespace=$_K8S_NAMESPACE',
  '--output=$_OUTPUT_PATH/backend/',
  '--annotation=gcb-build-id=$BUILD_ID',
  ]

- id: 'Deploy backend'
  name: 'gcr.io/cloud-builders/gke-deploy'
  dir: './'
  args: [
  'apply',
  '--filename=$_OUTPUT_PATH/backend/expanded/*',
  '--namespace=$_K8S_NAMESPACE',
  '--cluster=$_GKE_CLUSTER',
  '--location=$_GKE_ZONE',
  ]

- id: 'Prepare frontend for deployment'
  name: 'gcr.io/cloud-builders/gke-deploy'
  dir: './'
  args: [
  'prepare',
  '--filename=frontend/kubernetes-manifests',
  '--image=${_FRONTEND_IMAGE}:${_FRONTEND_VERSION}',
  '--app=$_K8S_APP_NAME',
  '--version=$_FRONTEND_VERSION',
  '--namespace=$_K8S_NAMESPACE',
  '--output=$_OUTPUT_PATH/frontend/',
  '--annotation=gcb-build-id=$BUILD_ID',
  ]

- id: 'Deploy frontend'
  name: 'gcr.io/cloud-builders/gke-deploy'
  dir: './'
  args: [
  'apply',
  '--filename=$_OUTPUT_PATH/frontend/expanded/*',
  '--namespace=$_K8S_NAMESPACE',
  '--cluster=$_GKE_CLUSTER',
  '--location=$_GKE_ZONE',
  ]

- id: 'e2e test the production deployment'
# Runs e2e test against the newly deployed build.
# Runs a local frontend server serving the built frontend.
# Does not pre-compile so it uses the frontend production build which does not enable error and cache interceptors in the frontend.
# Runs Protractor using a production staging configuration that does not run the cache or errors tests.
# BASE_URL is set to run against the production cluster.
# The configured test user has access to the production database.
# The production cluster runs with an environment file selected by NODE_ENV=production which sets the backend server to be run with no test paths available.  It also sets that the production database is in use.
  name: 'gcr.io/$PROJECT_ID/node-with-puppeteer'
  dir: './frontend'
  args: ['npm', 'run', 'e2e:production']

# Push the deployed images to the GCP Container Registry.
images: [
  '${_BACKEND_IMAGE}:${_BACKEND_VERSION}',
  '${_FRONTEND_IMAGE}:${_FRONTEND_VERSION}',
]

substitutions: # default values
  # PROJECT_ID: Cloud Build defaults to the ID of your Cloud project
  # BUILD_ID:Cloud Build defaults to the ID of your build
  _BACKEND_IMAGE: ''
  _FRONTEND_IMAGE: ''
  _BACKEND_VERSION: ''
  _FRONTEND_VERSION: ''
  _GKE_CLUSTER: ''
  _GKE_ZONE: ''
  _K8S_APP_NAME: ''
  _K8S_NAMESPACE: ''
  _OUTPUT_PATH: ''

# options:
  # substitution_option: 'ALLOW_LOOSE'

tags: [$_K8S_APP_NAME]

timeout: 1800s
