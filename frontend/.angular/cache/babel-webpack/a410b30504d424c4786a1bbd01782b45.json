{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, PLATFORM_ID, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule, DatePipe } from '@angular/common';\n/**\r\n * Injection token of logger config\r\n */\n\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\n/**\r\n * Injection token of logger config engine\r\n */\n\nconst TOKEN_LOGGER_CONFIG_ENGINE = 'TOKEN_LOGGER_CONFIG_ENGINE';\n\nclass NGXLoggerConfigEngine {\n  constructor(config) {\n    this.config = config;\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n\n\n  get level() {\n    return this.config.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n\n\n  get serverLogLevel() {\n    return this.config.serverLogLevel;\n  }\n\n  updateConfig(config) {\n    this.config = this._clone(config);\n  }\n\n  getConfig() {\n    return this._clone(this.config);\n  } // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\n\n\n  _clone(object) {\n    const cloneConfig = {\n      level: null\n    };\n    Object.keys(object).forEach(key => {\n      cloneConfig[key] = object[key];\n    });\n    return cloneConfig;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerConfigEngine.ɵfac = function NGXLoggerConfigEngine_Factory(t) {\n  return new (t || NGXLoggerConfigEngine)(i0.ɵɵinject(TOKEN_LOGGER_CONFIG));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerConfigEngine.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerConfigEngine,\n  factory: NGXLoggerConfigEngine.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerConfigEngine, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG]\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * Injection token of logger mapper service\r\n */\n\n\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\n\nclass NGXLoggerMapperService {\n  constructor(httpBackend) {\n    this.httpBackend = httpBackend;\n    /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\n\n    this.sourceMapCache = new Map();\n    /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\n\n    this.logPositionCache = new Map();\n  }\n  /**\r\n   * Returns the log position of the caller\r\n   * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n   * @param config\r\n   * @param metadata\r\n   * @returns\r\n   */\n\n\n  getLogPosition(config, metadata) {\n    const stackLine = this.getStackLine(config); // if we were not able to parse the stackLine, just return an empty Log Position\n\n    if (!stackLine) {\n      return of({\n        fileName: '',\n        lineNumber: 0,\n        columnNumber: 0\n      });\n    }\n\n    const logPosition = this.getLocalPosition(stackLine);\n\n    if (!config.enableSourceMaps) {\n      return of(logPosition);\n    }\n\n    const sourceMapLocation = this.getSourceMapLocation(stackLine);\n    return this.getSourceMap(sourceMapLocation, logPosition);\n  }\n  /**\r\n   * Get the stackline of the original caller\r\n   * @param config\r\n   * @returns null if stackline was not found\r\n   */\n\n\n  getStackLine(config) {\n    const error = new Error();\n\n    try {\n      // noinspection ExceptionCaughtLocallyJS\n      throw error;\n    } catch (e) {\n      try {\n        // Here are different examples of stacktrace \n        // Firefox (last line is the user code, the 4 first are ours):\n        // getStackLine@http://localhost:4200/main.js:358:23\n        // getCallerDetails@http://localhost:4200/main.js:557:44\n        // _log@http://localhost:4200/main.js:830:28\n        // debug@http://localhost:4200/main.js:652:14\n        // handleLog@http://localhost:4200/main.js:1158:29\n        // Chrome and Edge (last line is the user code):\n        // Error\n        // at Function.getStackLine (ngx-logger.js:329)\n        // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\n        // at NGXLogger._log (ngx-logger.js:801)\n        // at NGXLogger.info (ngx-logger.js:631)\n        // at AppComponent.handleLog (app.component.ts:38)\n        let defaultProxy = 4; // We make 4 functions call before getting here\n\n        const firstStackLine = error.stack.split('\\n')[0];\n\n        if (!firstStackLine.includes('.js:')) {\n          // The stacktrace starts with no function call (example in Chrome or Edge)\n          defaultProxy = defaultProxy + 1;\n        }\n\n        return error.stack.split('\\n')[defaultProxy + (config.proxiedSteps || 0)];\n      } catch (e) {\n        return null;\n      }\n    }\n  }\n  /**\r\n   * Get position of caller without using sourceMaps\r\n   * @param stackLine\r\n   * @returns\r\n   */\n\n\n  getLocalPosition(stackLine) {\n    // strip base path, then parse filename, line, and column, stackline looks like this :\n    // Firefox\n    // handleLog@http://localhost:4200/main.js:1158:29\n    // Chrome and Edge\n    // at AppComponent.handleLog (app.component.ts:38)\n    const positionStartIndex = stackLine.lastIndexOf('\\/');\n    let positionEndIndex = stackLine.indexOf(')');\n\n    if (positionEndIndex < 0) {\n      positionEndIndex = undefined;\n    }\n\n    const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\n    const dataArray = position.split(':');\n\n    if (dataArray.length === 3) {\n      return {\n        fileName: dataArray[0],\n        lineNumber: +dataArray[1],\n        columnNumber: +dataArray[2]\n      };\n    }\n\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n\n  getTranspileLocation(stackLine) {\n    // Example stackLine:\n    // Firefox : getStackLine@http://localhost:4200/main.js:358:23\n    // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\n    let locationStartIndex = stackLine.indexOf('(');\n\n    if (locationStartIndex < 0) {\n      locationStartIndex = stackLine.lastIndexOf('@');\n\n      if (locationStartIndex < 0) {\n        locationStartIndex = stackLine.lastIndexOf(' ');\n      }\n    }\n\n    let locationEndIndex = stackLine.indexOf(')');\n\n    if (locationEndIndex < 0) {\n      locationEndIndex = undefined;\n    }\n\n    return stackLine.substring(locationStartIndex + 1, locationEndIndex);\n  }\n  /**\r\n   * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n   * @param stackLine\r\n   * @returns\r\n   */\n\n\n  getSourceMapLocation(stackLine) {\n    const file = this.getTranspileLocation(stackLine);\n    const mapFullPath = file.substring(0, file.lastIndexOf(':'));\n    return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\n  }\n\n  getMapping(sourceMap, position) {\n    // => ';' indicates end of a line\n    // => ',' separates mappings in a line\n    // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\n    let sourceFileIndex = 0,\n        // second field\n    sourceCodeLine = 0,\n        // third field\n    sourceCodeColumn = 0; // fourth field\n\n    const lines = sourceMap.mappings.split(';');\n\n    for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\n      // reset column position to 0 after each line\n      let generatedCodeColumn = 0; // decode sections in line\n\n      const columns = lines[lineIndex].split(',');\n\n      for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\n        const decodedSection = vlq.decode(columns[columnIndex]);\n\n        if (decodedSection.length >= 4) {\n          // update relative positions\n          generatedCodeColumn += decodedSection[0];\n          sourceFileIndex += decodedSection[1];\n          sourceCodeLine += decodedSection[2];\n          sourceCodeColumn += decodedSection[3];\n        } // check if matching map\n\n\n        if (lineIndex === position.lineNumber) {\n          if (generatedCodeColumn === position.columnNumber) {\n            // matching column and line found\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: sourceCodeColumn\n            };\n          } else if (columnIndex + 1 === columns.length) {\n            // matching column not found, but line is correct\n            return {\n              fileName: sourceMap.sources[sourceFileIndex],\n              lineNumber: sourceCodeLine,\n              columnNumber: 0\n            };\n          }\n        }\n      }\n    } // failed if reached\n\n\n    return {\n      fileName: 'unknown',\n      lineNumber: 0,\n      columnNumber: 0\n    };\n  }\n  /**\r\n   * does the http get request to get the source map\r\n   * @param sourceMapLocation\r\n   * @param distPosition\r\n   */\n\n\n  getSourceMap(sourceMapLocation, distPosition) {\n    const req = new HttpRequest('GET', sourceMapLocation);\n    const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`; // if the specific log position is already in cache return it\n\n    if (this.logPositionCache.has(distPositionKey)) {\n      return this.logPositionCache.get(distPositionKey);\n    } // otherwise check if the source map is already cached for given source map location\n\n\n    if (!this.sourceMapCache.has(sourceMapLocation)) {\n      if (!this.httpBackend) {\n        console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\n        this.sourceMapCache.set(sourceMapLocation, of(null));\n      } else {\n        // obtain the source map if not cached\n        this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body), retry(3), shareReplay(1)));\n      }\n    } // at this point the source map is cached, use it to get specific log position mapping\n\n\n    const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map(sourceMap => {\n      // sourceMap can be null if HttpBackend is not provided for example\n      if (!sourceMap) {\n        return distPosition;\n      } // map generated position to source position\n\n\n      return this.getMapping(sourceMap, distPosition);\n    }), catchError(() => of(distPosition)), shareReplay(1)); // store specific log position in cache for given dest position and return it\n\n    this.logPositionCache.set(distPositionKey, logPosition$);\n    return logPosition$;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMapperService.ɵfac = function NGXLoggerMapperService_Factory(t) {\n  return new (t || NGXLoggerMapperService)(i0.ɵɵinject(i1.HttpBackend, 8));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMapperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMapperService,\n  factory: NGXLoggerMapperService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMapperService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * Injection token of logger metadata service\r\n */\n\n\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\n\nclass NGXLoggerMetadataService {\n  constructor(datePipe) {\n    this.datePipe = datePipe;\n  }\n\n  getMetadata(level, config, message, additional) {\n    const metadata = {\n      level: level,\n      additional: additional\n    }; // The user can send a function\n    // This is useful in order to compute string concatenation only when the log will actually be written\n\n    if (message && typeof message === 'function') {\n      metadata.message = message();\n    } else {\n      metadata.message = message;\n    }\n\n    if (config.timestampFormat) {\n      metadata.timestamp = this.datePipe.transform(new Date(), config.timestampFormat);\n    } else {\n      metadata.timestamp = new Date().toISOString();\n    }\n\n    return metadata;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMetadataService.ɵfac = function NGXLoggerMetadataService_Factory(t) {\n  return new (t || NGXLoggerMetadataService)(i0.ɵɵinject(i1$1.DatePipe));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerMetadataService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerMetadataService,\n  factory: NGXLoggerMetadataService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerMetadataService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1$1.DatePipe\n    }];\n  }, null);\n})(); // I kept this class alive only to avoid a breaking change with the old version\n// This class does not implement anything so it is useless and the interface is enough\n\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\n\n\nclass NGXLoggerMonitor {}\n/**\r\n * Injection token of logger metadata service\r\n */\n\n\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\n\nclass NGXLoggerRulesService {\n  shouldCallWriter(level, config, message, additional) {\n    return !config.disableConsoleLogging && level >= config.level;\n  }\n\n  shouldCallServer(level, config, message, additional) {\n    return !!config.serverLoggingUrl && level >= config.serverLogLevel;\n  }\n\n  shouldCallMonitor(level, config, message, additional) {\n    // The default behavior is to call the monitor only if the writer or the server is called\n    return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerRulesService.ɵfac = function NGXLoggerRulesService_Factory(t) {\n  return new (t || NGXLoggerRulesService)();\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerRulesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerRulesService,\n  factory: NGXLoggerRulesService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerRulesService, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\r\n * Injection token of logger server service\r\n */\n\n\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\n\nclass NGXLoggerServerService {\n  constructor(httpBackend) {\n    this.httpBackend = httpBackend;\n  }\n  /**\r\n   * Transforms an error object into a readable string (taking only the stack)\r\n   * This is needed because JSON.stringify would return \"{}\"\r\n   * @param err the error object\r\n   * @returns The stack of the error\r\n   */\n\n\n  secureErrorObject(err) {\n    return err === null || err === void 0 ? void 0 : err.stack;\n  }\n  /**\r\n   * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n   * Basically it just replaces unstringifiable object to a string mentioning an error\r\n   * @param additional The additional data to be sent\r\n   * @returns The additional data secured\r\n   */\n\n\n  secureAdditionalParameters(additional) {\n    if (additional === null || additional === undefined) {\n      return null;\n    }\n\n    return additional.map((next, idx) => {\n      try {\n        if (next instanceof Error) {\n          return this.secureErrorObject(next);\n        } // We just want to make sure the JSON can be parsed, we do not want to actually change the type\n\n\n        if (typeof next === 'object') {\n          JSON.stringify(next);\n        }\n\n        return next;\n      } catch (e) {\n        return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\n      }\n    });\n  }\n  /**\r\n   * Transforms the message so that it can be sent to the server\r\n   * @param message the message to be sent\r\n   * @returns the message secured\r\n   */\n\n\n  secureMessage(message) {\n    try {\n      if (message instanceof Error) {\n        return this.secureErrorObject(message);\n      }\n\n      if (typeof message !== 'string') {\n        message = JSON.stringify(message, null, 2);\n      }\n    } catch (e) {\n      message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\n    }\n\n    return message;\n  }\n\n  logOnServer(url, logContent, options) {\n    // HttpBackend skips all HttpInterceptors\n    // They may log errors using this service causing circular calls\n    const req = new HttpRequest('POST', url, logContent, options || {});\n\n    if (!this.httpBackend) {\n      console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\n      return of(null);\n    }\n\n    return this.httpBackend.handle(req).pipe(filter(e => e instanceof HttpResponse), map(httpResponse => httpResponse.body));\n  }\n  /**\r\n   * Customise the data sent to the API\r\n   * @param metadata the data provided by NGXLogger\r\n   * @returns the data that will be sent to the API in the body\r\n   */\n\n\n  customiseRequestBody(metadata) {\n    // In our API the body is not customised\n    return metadata;\n  }\n\n  sendToServer(metadata, config) {\n    // Copying metadata locally because we don't want to change the object for the caller\n    const localMetadata = Object.assign({}, metadata);\n    localMetadata.additional = this.secureAdditionalParameters(localMetadata.additional);\n    localMetadata.message = this.secureMessage(metadata.message); // Allow users to customise the data sent to the API\n\n    const requestBody = this.customiseRequestBody(metadata);\n    const headers = config.customHttpHeaders || new HttpHeaders();\n\n    if (!headers.has('Content-Type')) {\n      headers.set('Content-Type', 'application/json');\n    }\n\n    this.logOnServer(config.serverLoggingUrl, requestBody, {\n      headers,\n      params: config.customHttpParams || new HttpParams(),\n      responseType: config.httpResponseType || 'json',\n      withCredentials: config.withCredentials || false\n    }).pipe(catchError(err => {\n      // Do not use NGXLogger here because this could cause an infinite loop \n      console.error('NGXLogger: Failed to log on server', err);\n      return throwError(err);\n    })).subscribe();\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerServerService.ɵfac = function NGXLoggerServerService_Factory(t) {\n  return new (t || NGXLoggerServerService)(i0.ɵɵinject(i1.HttpBackend, 8));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerServerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerServerService,\n  factory: NGXLoggerServerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerServerService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.HttpBackend,\n      decorators: [{\n        type: Optional\n      }]\n    }];\n  }, null);\n})();\n/**\r\n * Injection token of logger writer service\r\n */\n\n\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\nvar NgxLoggerLevel;\n\n(function (NgxLoggerLevel) {\n  NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\n  NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\n  NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\n  NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\n  NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\n  NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\n  NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\n\nconst DEFAULT_COLOR_SCHEME = ['purple', 'teal', 'gray', 'gray', 'red', 'red', 'red'];\n\nclass NGXLoggerWriterService {\n  constructor(platformId) {\n    this.platformId = platformId;\n    this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent && !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\n    this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\n  }\n  /** Generate a \"meta\" string that is displayed before the content sent to the log function */\n\n\n  prepareMetaString(metadata, config) {\n    const fileDetails = config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\n    return `${metadata.timestamp} ${NgxLoggerLevel[metadata.level]} ${fileDetails}`;\n  }\n  /** Get the color to use when writing to console */\n\n\n  getColor(metadata, config) {\n    var _a;\n\n    const configColorScheme = (_a = config.colorScheme) !== null && _a !== void 0 ? _a : DEFAULT_COLOR_SCHEME; // this is needed to avoid a build error\n\n    if (metadata.level === NgxLoggerLevel.OFF) {\n      return undefined;\n    }\n\n    return configColorScheme[metadata.level];\n  }\n  /** Log to the console specifically for IE */\n\n\n  logIE(metadata, config, metaString) {\n    // Coloring doesn't work in IE\n    // make sure additional isn't null or undefined so that ...additional doesn't error\n    const additional = metadata.additional || [];\n\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`${metaString} `, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`${metaString} `, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.INFO:\n        console.info(`${metaString} `, metadata.message, ...additional);\n        break;\n\n      default:\n        console.log(`${metaString} `, metadata.message, ...additional);\n    }\n  }\n  /** Log to the console */\n\n\n  logModern(metadata, config, metaString) {\n    const color = this.getColor(metadata, config); // make sure additional isn't null or undefined so that ...additional doesn't error\n\n    const additional = metadata.additional || [];\n\n    switch (metadata.level) {\n      case NgxLoggerLevel.WARN:\n        console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.ERROR:\n      case NgxLoggerLevel.FATAL:\n        console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n\n      case NgxLoggerLevel.INFO:\n        console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n      //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\n      // the console.trace statement\n      // case NgxLoggerLevel.TRACE:\n      //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\n      //   break;\n\n      case NgxLoggerLevel.DEBUG:\n        console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n        break;\n\n      default:\n        console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\n    }\n  }\n  /** Write the content sent to the log function to the console */\n\n\n  writeMessage(metadata, config) {\n    const metaString = this.prepareMetaString(metadata, config);\n    this.logFunc(metadata, config, metaString);\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerWriterService.ɵfac = function NGXLoggerWriterService_Factory(t) {\n  return new (t || NGXLoggerWriterService)(i0.ɵɵinject(PLATFORM_ID));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLoggerWriterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLoggerWriterService,\n  factory: NGXLoggerWriterService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLoggerWriterService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [PLATFORM_ID]\n      }]\n    }];\n  }, null);\n})();\n\nclass NGXLogger {\n  constructor(configEngine, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.configEngine = configEngine;\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService; // The config engine is provided with an inject token which means the user has all control on the scope of that instance\n    // By default each loggerService instance has its own configEngine (see example in \"not-a-singleton\" projects)\n\n    this.configEngine = configEngine;\n  }\n  /** Get a readonly access to the level configured for the NGXLogger */\n\n\n  get level() {\n    return this.configEngine.level;\n  }\n  /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\n\n\n  get serverLogLevel() {\n    return this.configEngine.serverLogLevel;\n  }\n\n  trace(message, ...additional) {\n    this._log(NgxLoggerLevel.TRACE, message, additional);\n  }\n\n  debug(message, ...additional) {\n    this._log(NgxLoggerLevel.DEBUG, message, additional);\n  }\n\n  info(message, ...additional) {\n    this._log(NgxLoggerLevel.INFO, message, additional);\n  }\n\n  log(message, ...additional) {\n    this._log(NgxLoggerLevel.LOG, message, additional);\n  }\n\n  warn(message, ...additional) {\n    this._log(NgxLoggerLevel.WARN, message, additional);\n  }\n\n  error(message, ...additional) {\n    this._log(NgxLoggerLevel.ERROR, message, additional);\n  }\n\n  fatal(message, ...additional) {\n    this._log(NgxLoggerLevel.FATAL, message, additional);\n  }\n  /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\n\n\n  setCustomHttpHeaders(headers) {\n    const config = this.getConfigSnapshot();\n    config.customHttpHeaders = headers;\n    this.updateConfig(config);\n  }\n  /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\n\n\n  setCustomParams(params) {\n    const config = this.getConfigSnapshot();\n    config.customHttpParams = params;\n    this.updateConfig(config);\n  }\n  /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\n\n\n  setWithCredentialsOptionValue(withCredentials) {\n    const config = this.getConfigSnapshot();\n    config.withCredentials = withCredentials;\n    this.updateConfig(config);\n  }\n  /**\r\n   * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n   *\r\n   * There is only one monitor, registering one will overwrite the last one if there was one\r\n   * @param monitor\r\n   */\n\n\n  registerMonitor(monitor) {\n    this._loggerMonitor = monitor;\n  }\n  /** Set config of logger\r\n   *\r\n   * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n   */\n\n\n  updateConfig(config) {\n    this.configEngine.updateConfig(config);\n  }\n  /** Get config of logger */\n\n\n  getConfigSnapshot() {\n    return this.configEngine.getConfig();\n  }\n\n  _log(level, message, additional = []) {\n    const config = this.configEngine.getConfig();\n    const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\n    const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\n    const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\n\n    if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\n      // If nothing is to be called we return\n      return;\n    }\n\n    const metadata = this.metadataService.getMetadata(level, config, message, additional);\n    this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\n      if (logPosition) {\n        metadata.fileName = logPosition.fileName;\n        metadata.lineNumber = logPosition.lineNumber;\n        metadata.columnNumber = logPosition.columnNumber;\n      }\n\n      if (shouldCallMonitor && this._loggerMonitor) {\n        this._loggerMonitor.onLog(metadata, config);\n      }\n\n      if (shouldCallWriter) {\n        this.writerService.writeMessage(metadata, config);\n      }\n\n      if (shouldCallServer) {\n        this.serverService.sendToServer(metadata, config);\n      }\n    });\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLogger.ɵfac = function NGXLogger_Factory(t) {\n  return new (t || NGXLogger)(i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nNGXLogger.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NGXLogger,\n  factory: NGXLogger.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NGXLogger, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})(); // Keeping this to avoid any breaking change for now, this class should be removed later\n\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n * @deprecated The logger is now fully customisable so this class is now useless\r\n */\n\n\nclass CustomNGXLoggerService {\n  constructor(configEngine, metadataService, ruleService, mapperService, writerService, serverService) {\n    this.configEngine = configEngine;\n    this.metadataService = metadataService;\n    this.ruleService = ruleService;\n    this.mapperService = mapperService;\n    this.writerService = writerService;\n    this.serverService = serverService;\n  }\n  /**\r\n   * Create an instance of a logger\r\n   * @deprecated The logger is now fully customisable so this function is now useless, if you want a specific instance of NGXLogger, either use the new keyword or Angular dependency injection\r\n   * @param config\r\n   * @param serverService\r\n   * @param logMonitor\r\n   * @param mapperService\r\n   * @returns\r\n   */\n\n\n  create(config, serverService, logMonitor, mapperService) {\n    this.configEngine.updateConfig(config);\n    const logger = new NGXLogger(this.configEngine, this.metadataService, this.ruleService, mapperService || this.mapperService, this.writerService, serverService || this.serverService);\n\n    if (logMonitor) {\n      logger.registerMonitor(logMonitor);\n    }\n\n    return logger;\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nCustomNGXLoggerService.ɵfac = function CustomNGXLoggerService_Factory(t) {\n  return new (t || CustomNGXLoggerService)(i0.ɵɵinject(TOKEN_LOGGER_CONFIG_ENGINE), i0.ɵɵinject(TOKEN_LOGGER_METADATA_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_RULES_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_MAPPER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_WRITER_SERVICE), i0.ɵɵinject(TOKEN_LOGGER_SERVER_SERVICE));\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nCustomNGXLoggerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: CustomNGXLoggerService,\n  factory: CustomNGXLoggerService.ɵfac,\n  providedIn: 'root'\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CustomNGXLoggerService, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_CONFIG_ENGINE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_METADATA_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_RULES_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_MAPPER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_WRITER_SERVICE]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [TOKEN_LOGGER_SERVER_SERVICE]\n      }]\n    }];\n  }, null);\n})();\n\nclass LoggerModule {\n  static forRoot(config, customProvider) {\n    if (!customProvider) {\n      customProvider = {};\n    } // default config provider\n\n\n    if (!customProvider.configProvider) {\n      customProvider.configProvider = {\n        provide: TOKEN_LOGGER_CONFIG,\n        useValue: config || {}\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\n        throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\n      }\n    } // default configEngine provider\n\n\n    if (!customProvider.configEngineProvider) {\n      customProvider.configEngineProvider = {\n        provide: TOKEN_LOGGER_CONFIG_ENGINE,\n        useClass: NGXLoggerConfigEngine\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.configEngineProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE) {\n        throw new Error(`Wrong injection token for configEngineProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE}' and you used '${customProvider.configEngineProvider.provide}'`);\n      }\n    } // default metadata provider\n\n\n    if (!customProvider.metadataProvider) {\n      customProvider.metadataProvider = {\n        provide: TOKEN_LOGGER_METADATA_SERVICE,\n        useClass: NGXLoggerMetadataService\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\n        throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\n      }\n    } // default rule provider\n\n\n    if (!customProvider.ruleProvider) {\n      customProvider.ruleProvider = {\n        provide: TOKEN_LOGGER_RULES_SERVICE,\n        useClass: NGXLoggerRulesService\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\n        throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\n      }\n    } // default mapper provider\n\n\n    if (!customProvider.mapperProvider) {\n      customProvider.mapperProvider = {\n        provide: TOKEN_LOGGER_MAPPER_SERVICE,\n        useClass: NGXLoggerMapperService\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\n        throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\n      }\n    } // default writer provider\n\n\n    if (!customProvider.writerProvider) {\n      customProvider.writerProvider = {\n        provide: TOKEN_LOGGER_WRITER_SERVICE,\n        useClass: NGXLoggerWriterService\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\n        throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    } // default server provider\n\n\n    if (!customProvider.serverProvider) {\n      customProvider.serverProvider = {\n        provide: TOKEN_LOGGER_SERVER_SERVICE,\n        useClass: NGXLoggerServerService\n      };\n    } else {\n      // if the user provided its own config, we just make sure the injection token is correct\n      if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\n        throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\n      }\n    }\n\n    return {\n      ngModule: LoggerModule,\n      providers: [NGXLogger, customProvider.configProvider, customProvider.configEngineProvider, customProvider.metadataProvider, customProvider.ruleProvider, customProvider.mapperProvider, customProvider.writerProvider, customProvider.serverProvider, CustomNGXLoggerService]\n    };\n  }\n\n  static forChild() {\n    // todo : this forChild is useless for now because nothing is different from forRoot.\n    // This should be implemented so that user can change the providers in the forChild\n    return {\n      ngModule: LoggerModule\n    };\n  }\n\n}\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nLoggerModule.ɵfac = function LoggerModule_Factory(t) {\n  return new (t || LoggerModule)();\n};\n/** @nocollapse */\n\n/** @nocollapse */\n\n\nLoggerModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LoggerModule\n});\n/** @nocollapse */\n\n/** @nocollapse */\n\nLoggerModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [DatePipe // DatePipe is required by metadata-service.ts\n  ],\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LoggerModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule],\n      providers: [DatePipe // DatePipe is required by metadata-service.ts\n      ]\n    }]\n  }], null, null);\n})();\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };","map":{"version":3,"sources":["/home/cname87/Dropbox/software/projects/main/project-perform-cb/frontend/node_modules/ngx-logger/fesm2015/ngx-logger.mjs"],"names":["i0","Injectable","Inject","Optional","PLATFORM_ID","NgModule","i1","HttpRequest","HttpResponse","HttpHeaders","HttpParams","of","throwError","filter","map","retry","shareReplay","catchError","take","vlq","i1$1","isPlatformBrowser","CommonModule","DatePipe","TOKEN_LOGGER_CONFIG","TOKEN_LOGGER_CONFIG_ENGINE","NGXLoggerConfigEngine","constructor","config","level","serverLogLevel","updateConfig","_clone","getConfig","object","cloneConfig","Object","keys","forEach","key","ɵfac","ɵprov","type","undefined","decorators","args","TOKEN_LOGGER_MAPPER_SERVICE","NGXLoggerMapperService","httpBackend","sourceMapCache","Map","logPositionCache","getLogPosition","metadata","stackLine","getStackLine","fileName","lineNumber","columnNumber","logPosition","getLocalPosition","enableSourceMaps","sourceMapLocation","getSourceMapLocation","getSourceMap","error","Error","e","defaultProxy","firstStackLine","stack","split","includes","proxiedSteps","positionStartIndex","lastIndexOf","positionEndIndex","indexOf","position","substring","dataArray","length","getTranspileLocation","locationStartIndex","locationEndIndex","file","mapFullPath","getMapping","sourceMap","sourceFileIndex","sourceCodeLine","sourceCodeColumn","lines","mappings","lineIndex","generatedCodeColumn","columns","columnIndex","decodedSection","decode","sources","distPosition","req","distPositionKey","has","get","console","set","handle","pipe","httpResponse","body","logPosition$","HttpBackend","TOKEN_LOGGER_METADATA_SERVICE","NGXLoggerMetadataService","datePipe","getMetadata","message","additional","timestampFormat","timestamp","transform","Date","toISOString","NGXLoggerMonitor","TOKEN_LOGGER_RULES_SERVICE","NGXLoggerRulesService","shouldCallWriter","disableConsoleLogging","shouldCallServer","serverLoggingUrl","shouldCallMonitor","TOKEN_LOGGER_SERVER_SERVICE","NGXLoggerServerService","secureErrorObject","err","secureAdditionalParameters","next","idx","JSON","stringify","secureMessage","logOnServer","url","logContent","options","customiseRequestBody","sendToServer","localMetadata","assign","requestBody","headers","customHttpHeaders","params","customHttpParams","responseType","httpResponseType","withCredentials","subscribe","TOKEN_LOGGER_WRITER_SERVICE","NgxLoggerLevel","DEFAULT_COLOR_SCHEME","NGXLoggerWriterService","platformId","isIE","navigator","userAgent","match","logFunc","logIE","bind","logModern","prepareMetaString","fileDetails","disableFileDetails","getColor","_a","configColorScheme","colorScheme","OFF","metaString","WARN","warn","ERROR","FATAL","INFO","info","log","color","DEBUG","debug","writeMessage","NGXLogger","configEngine","metadataService","ruleService","mapperService","writerService","serverService","trace","_log","TRACE","LOG","fatal","setCustomHttpHeaders","getConfigSnapshot","setCustomParams","setWithCredentialsOptionValue","registerMonitor","monitor","_loggerMonitor","onLog","providedIn","CustomNGXLoggerService","create","logMonitor","logger","LoggerModule","forRoot","customProvider","configProvider","provide","useValue","configEngineProvider","useClass","metadataProvider","ruleProvider","mapperProvider","writerProvider","serverProvider","ngModule","providers","forChild","ɵmod","ɵinj","imports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, Inject, Optional, PLATFORM_ID, NgModule } from '@angular/core';\nimport * as i1 from '@angular/common/http';\nimport { HttpRequest, HttpResponse, HttpHeaders, HttpParams } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { filter, map, retry, shareReplay, catchError, take } from 'rxjs/operators';\nimport * as vlq from 'vlq';\nimport * as i1$1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule, DatePipe } from '@angular/common';\n\n/**\r\n * Injection token of logger config\r\n */\r\nconst TOKEN_LOGGER_CONFIG = 'TOKEN_LOGGER_CONFIG';\n\n/**\r\n * Injection token of logger config engine\r\n */\r\nconst TOKEN_LOGGER_CONFIG_ENGINE = 'TOKEN_LOGGER_CONFIG_ENGINE';\n\nclass NGXLoggerConfigEngine {\r\n    constructor(config) {\r\n        this.config = config;\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.config.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.config.serverLogLevel;\r\n    }\r\n    updateConfig(config) {\r\n        this.config = this._clone(config);\r\n    }\r\n    getConfig() {\r\n        return this._clone(this.config);\r\n    }\r\n    // TODO: This is a shallow clone, If the config ever becomes hierarchical we must make this a deep clone\r\n    _clone(object) {\r\n        const cloneConfig = { level: null };\r\n        Object.keys(object).forEach((key) => {\r\n            cloneConfig[key] = object[key];\r\n        });\r\n        return cloneConfig;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerConfigEngine.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerConfigEngine, deps: [{ token: TOKEN_LOGGER_CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerConfigEngine.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerConfigEngine });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerConfigEngine, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_CONFIG]\r\n                    }] }];\r\n    } });\n\n/**\r\n * Injection token of logger mapper service\r\n */\r\nconst TOKEN_LOGGER_MAPPER_SERVICE = 'TOKEN_LOGGER_MAPPER_SERVICE';\n\nclass NGXLoggerMapperService {\r\n    constructor(httpBackend) {\r\n        this.httpBackend = httpBackend;\r\n        /** cache for source maps, key is source map location, ie. 'http://localhost:4200/main.js.map' */\r\n        this.sourceMapCache = new Map();\r\n        /** cache for specific log position, key is the dist position, ie 'main.js:339:21' */\r\n        this.logPositionCache = new Map();\r\n    }\r\n    /**\r\n     * Returns the log position of the caller\r\n     * If sourceMaps are enabled, it attemps to get the source map from the server, and use that to parse the position\r\n     * @param config\r\n     * @param metadata\r\n     * @returns\r\n     */\r\n    getLogPosition(config, metadata) {\r\n        const stackLine = this.getStackLine(config);\r\n        // if we were not able to parse the stackLine, just return an empty Log Position\r\n        if (!stackLine) {\r\n            return of({ fileName: '', lineNumber: 0, columnNumber: 0 });\r\n        }\r\n        const logPosition = this.getLocalPosition(stackLine);\r\n        if (!config.enableSourceMaps) {\r\n            return of(logPosition);\r\n        }\r\n        const sourceMapLocation = this.getSourceMapLocation(stackLine);\r\n        return this.getSourceMap(sourceMapLocation, logPosition);\r\n    }\r\n    /**\r\n     * Get the stackline of the original caller\r\n     * @param config\r\n     * @returns null if stackline was not found\r\n     */\r\n    getStackLine(config) {\r\n        const error = new Error();\r\n        try {\r\n            // noinspection ExceptionCaughtLocallyJS\r\n            throw error;\r\n        }\r\n        catch (e) {\r\n            try {\r\n                // Here are different examples of stacktrace \r\n                // Firefox (last line is the user code, the 4 first are ours):\r\n                // getStackLine@http://localhost:4200/main.js:358:23\r\n                // getCallerDetails@http://localhost:4200/main.js:557:44\r\n                // _log@http://localhost:4200/main.js:830:28\r\n                // debug@http://localhost:4200/main.js:652:14\r\n                // handleLog@http://localhost:4200/main.js:1158:29\r\n                // Chrome and Edge (last line is the user code):\r\n                // Error\r\n                // at Function.getStackLine (ngx-logger.js:329)\r\n                // at NGXMapperService.getCallerDetails (ngx-logger.js:528)\r\n                // at NGXLogger._log (ngx-logger.js:801)\r\n                // at NGXLogger.info (ngx-logger.js:631)\r\n                // at AppComponent.handleLog (app.component.ts:38)\r\n                let defaultProxy = 4; // We make 4 functions call before getting here\r\n                const firstStackLine = error.stack.split('\\n')[0];\r\n                if (!firstStackLine.includes('.js:')) {\r\n                    // The stacktrace starts with no function call (example in Chrome or Edge)\r\n                    defaultProxy = defaultProxy + 1;\r\n                }\r\n                return error.stack.split('\\n')[(defaultProxy + (config.proxiedSteps || 0))];\r\n            }\r\n            catch (e) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Get position of caller without using sourceMaps\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getLocalPosition(stackLine) {\r\n        // strip base path, then parse filename, line, and column, stackline looks like this :\r\n        // Firefox\r\n        // handleLog@http://localhost:4200/main.js:1158:29\r\n        // Chrome and Edge\r\n        // at AppComponent.handleLog (app.component.ts:38)\r\n        const positionStartIndex = stackLine.lastIndexOf('\\/');\r\n        let positionEndIndex = stackLine.indexOf(')');\r\n        if (positionEndIndex < 0) {\r\n            positionEndIndex = undefined;\r\n        }\r\n        const position = stackLine.substring(positionStartIndex + 1, positionEndIndex);\r\n        const dataArray = position.split(':');\r\n        if (dataArray.length === 3) {\r\n            return { fileName: dataArray[0], lineNumber: +dataArray[1], columnNumber: +dataArray[2] };\r\n        }\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    getTranspileLocation(stackLine) {\r\n        // Example stackLine:\r\n        // Firefox : getStackLine@http://localhost:4200/main.js:358:23\r\n        // Chrome and Edge : at Function.getStackLine (ngx-logger.js:329)\r\n        let locationStartIndex = stackLine.indexOf('(');\r\n        if (locationStartIndex < 0) {\r\n            locationStartIndex = stackLine.lastIndexOf('@');\r\n            if (locationStartIndex < 0) {\r\n                locationStartIndex = stackLine.lastIndexOf(' ');\r\n            }\r\n        }\r\n        let locationEndIndex = stackLine.indexOf(')');\r\n        if (locationEndIndex < 0) {\r\n            locationEndIndex = undefined;\r\n        }\r\n        return stackLine.substring(locationStartIndex + 1, locationEndIndex);\r\n    }\r\n    /**\r\n     * Gets the URL of the sourcemap (the URL can be relative or absolute, it is browser dependant)\r\n     * @param stackLine\r\n     * @returns\r\n     */\r\n    getSourceMapLocation(stackLine) {\r\n        const file = this.getTranspileLocation(stackLine);\r\n        const mapFullPath = file.substring(0, file.lastIndexOf(':'));\r\n        return mapFullPath.substring(0, mapFullPath.lastIndexOf(':')) + '.map';\r\n    }\r\n    getMapping(sourceMap, position) {\r\n        // => ';' indicates end of a line\r\n        // => ',' separates mappings in a line\r\n        // decoded mapping => [ generatedCodeColumn, sourceFileIndex, sourceCodeLine, sourceCodeColumn, nameIndex ]\r\n        let sourceFileIndex = 0, // second field\r\n        sourceCodeLine = 0, // third field\r\n        sourceCodeColumn = 0; // fourth field\r\n        const lines = sourceMap.mappings.split(';');\r\n        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {\r\n            // reset column position to 0 after each line\r\n            let generatedCodeColumn = 0;\r\n            // decode sections in line\r\n            const columns = lines[lineIndex].split(',');\r\n            for (let columnIndex = 0; columnIndex < columns.length; columnIndex++) {\r\n                const decodedSection = vlq.decode(columns[columnIndex]);\r\n                if (decodedSection.length >= 4) {\r\n                    // update relative positions\r\n                    generatedCodeColumn += decodedSection[0];\r\n                    sourceFileIndex += decodedSection[1];\r\n                    sourceCodeLine += decodedSection[2];\r\n                    sourceCodeColumn += decodedSection[3];\r\n                }\r\n                // check if matching map\r\n                if (lineIndex === position.lineNumber) {\r\n                    if (generatedCodeColumn === position.columnNumber) {\r\n                        // matching column and line found\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: sourceCodeColumn };\r\n                    }\r\n                    else if (columnIndex + 1 === columns.length) {\r\n                        // matching column not found, but line is correct\r\n                        return { fileName: sourceMap.sources[sourceFileIndex], lineNumber: sourceCodeLine, columnNumber: 0 };\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // failed if reached\r\n        return { fileName: 'unknown', lineNumber: 0, columnNumber: 0 };\r\n    }\r\n    /**\r\n     * does the http get request to get the source map\r\n     * @param sourceMapLocation\r\n     * @param distPosition\r\n     */\r\n    getSourceMap(sourceMapLocation, distPosition) {\r\n        const req = new HttpRequest('GET', sourceMapLocation);\r\n        const distPositionKey = `${distPosition.fileName}:${distPosition.lineNumber}:${distPosition.columnNumber}`;\r\n        // if the specific log position is already in cache return it\r\n        if (this.logPositionCache.has(distPositionKey)) {\r\n            return this.logPositionCache.get(distPositionKey);\r\n        }\r\n        // otherwise check if the source map is already cached for given source map location\r\n        if (!this.sourceMapCache.has(sourceMapLocation)) {\r\n            if (!this.httpBackend) {\r\n                console.error('NGXLogger : Can\\'t get sourcemap because HttpBackend is not provided. You need to import HttpClientModule');\r\n                this.sourceMapCache.set(sourceMapLocation, of(null));\r\n            }\r\n            else {\r\n                // obtain the source map if not cached\r\n                this.sourceMapCache.set(sourceMapLocation, this.httpBackend.handle(req).pipe(filter((e) => e instanceof HttpResponse), map((httpResponse) => httpResponse.body), retry(3), shareReplay(1)));\r\n            }\r\n        }\r\n        // at this point the source map is cached, use it to get specific log position mapping\r\n        const logPosition$ = this.sourceMapCache.get(sourceMapLocation).pipe(map((sourceMap) => {\r\n            // sourceMap can be null if HttpBackend is not provided for example\r\n            if (!sourceMap) {\r\n                return distPosition;\r\n            }\r\n            // map generated position to source position\r\n            return this.getMapping(sourceMap, distPosition);\r\n        }), catchError(() => of(distPosition)), shareReplay(1));\r\n        // store specific log position in cache for given dest position and return it\r\n        this.logPositionCache.set(distPositionKey, logPosition$);\r\n        return logPosition$;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, deps: [{ token: i1.HttpBackend, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMapperService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMapperService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: i1.HttpBackend, decorators: [{\r\n                        type: Optional\r\n                    }] }];\r\n    } });\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_METADATA_SERVICE = 'TOKEN_LOGGER_METADATA_SERVICE';\n\nclass NGXLoggerMetadataService {\r\n    constructor(datePipe) {\r\n        this.datePipe = datePipe;\r\n    }\r\n    getMetadata(level, config, message, additional) {\r\n        const metadata = {\r\n            level: level,\r\n            additional: additional,\r\n        };\r\n        // The user can send a function\r\n        // This is useful in order to compute string concatenation only when the log will actually be written\r\n        if (message && typeof message === 'function') {\r\n            metadata.message = message();\r\n        }\r\n        else {\r\n            metadata.message = message;\r\n        }\r\n        if (config.timestampFormat) {\r\n            metadata.timestamp = this.datePipe.transform(new Date(), config.timestampFormat);\r\n        }\r\n        else {\r\n            metadata.timestamp = new Date().toISOString();\r\n        }\r\n        return metadata;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, deps: [{ token: i1$1.DatePipe }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerMetadataService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerMetadataService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () { return [{ type: i1$1.DatePipe }]; } });\n\n// I kept this class alive only to avoid a breaking change with the old version\r\n// This class does not implement anything so it is useless and the interface is enough\r\n/**\r\n * @deprecated this class does not implement anything thus being useless, you should rather implements @see INGXLoggerMonitor\r\n */\r\nclass NGXLoggerMonitor {\r\n}\n\n/**\r\n * Injection token of logger metadata service\r\n */\r\nconst TOKEN_LOGGER_RULES_SERVICE = 'TOKEN_LOGGER_RULES_SERVICE';\n\nclass NGXLoggerRulesService {\r\n    shouldCallWriter(level, config, message, additional) {\r\n        return !config.disableConsoleLogging && level >= config.level;\r\n    }\r\n    shouldCallServer(level, config, message, additional) {\r\n        return !!config.serverLoggingUrl && level >= config.serverLogLevel;\r\n    }\r\n    shouldCallMonitor(level, config, message, additional) {\r\n        // The default behavior is to call the monitor only if the writer or the server is called\r\n        return this.shouldCallWriter(level, config, message, additional) || this.shouldCallServer(level, config, message, additional);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerRulesService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerRulesService, decorators: [{\r\n            type: Injectable\r\n        }] });\n\n/**\r\n * Injection token of logger server service\r\n */\r\nconst TOKEN_LOGGER_SERVER_SERVICE = 'TOKEN_LOGGER_SERVER_SERVICE';\n\nclass NGXLoggerServerService {\r\n    constructor(httpBackend) {\r\n        this.httpBackend = httpBackend;\r\n    }\r\n    /**\r\n     * Transforms an error object into a readable string (taking only the stack)\r\n     * This is needed because JSON.stringify would return \"{}\"\r\n     * @param err the error object\r\n     * @returns The stack of the error\r\n     */\r\n    secureErrorObject(err) {\r\n        return err === null || err === void 0 ? void 0 : err.stack;\r\n    }\r\n    /**\r\n     * Transforms the additional parameters to avoid any json error when sending the data to the server\r\n     * Basically it just replaces unstringifiable object to a string mentioning an error\r\n     * @param additional The additional data to be sent\r\n     * @returns The additional data secured\r\n     */\r\n    secureAdditionalParameters(additional) {\r\n        if (additional === null || additional === undefined) {\r\n            return null;\r\n        }\r\n        return additional.map((next, idx) => {\r\n            try {\r\n                if (next instanceof Error) {\r\n                    return this.secureErrorObject(next);\r\n                }\r\n                // We just want to make sure the JSON can be parsed, we do not want to actually change the type\r\n                if (typeof next === 'object') {\r\n                    JSON.stringify(next);\r\n                }\r\n                return next;\r\n            }\r\n            catch (e) {\r\n                return `The additional[${idx}] value could not be parsed using JSON.stringify().`;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Transforms the message so that it can be sent to the server\r\n     * @param message the message to be sent\r\n     * @returns the message secured\r\n     */\r\n    secureMessage(message) {\r\n        try {\r\n            if (message instanceof Error) {\r\n                return this.secureErrorObject(message);\r\n            }\r\n            if (typeof message !== 'string') {\r\n                message = JSON.stringify(message, null, 2);\r\n            }\r\n        }\r\n        catch (e) {\r\n            message = 'The provided \"message\" value could not be parsed with JSON.stringify().';\r\n        }\r\n        return message;\r\n    }\r\n    logOnServer(url, logContent, options) {\r\n        // HttpBackend skips all HttpInterceptors\r\n        // They may log errors using this service causing circular calls\r\n        const req = new HttpRequest('POST', url, logContent, options || {});\r\n        if (!this.httpBackend) {\r\n            console.error('NGXLogger : Can\\'t log on server because HttpBackend is not provided. You need to import HttpClientModule');\r\n            return of(null);\r\n        }\r\n        return this.httpBackend.handle(req).pipe(filter(e => e instanceof HttpResponse), map((httpResponse) => httpResponse.body));\r\n    }\r\n    /**\r\n     * Customise the data sent to the API\r\n     * @param metadata the data provided by NGXLogger\r\n     * @returns the data that will be sent to the API in the body\r\n     */\r\n    customiseRequestBody(metadata) {\r\n        // In our API the body is not customised\r\n        return metadata;\r\n    }\r\n    sendToServer(metadata, config) {\r\n        // Copying metadata locally because we don't want to change the object for the caller\r\n        const localMetadata = Object.assign({}, metadata);\r\n        localMetadata.additional = this.secureAdditionalParameters(localMetadata.additional);\r\n        localMetadata.message = this.secureMessage(metadata.message);\r\n        // Allow users to customise the data sent to the API\r\n        const requestBody = this.customiseRequestBody(metadata);\r\n        const headers = config.customHttpHeaders || new HttpHeaders();\r\n        if (!headers.has('Content-Type')) {\r\n            headers.set('Content-Type', 'application/json');\r\n        }\r\n        this.logOnServer(config.serverLoggingUrl, requestBody, {\r\n            headers,\r\n            params: config.customHttpParams || new HttpParams(),\r\n            responseType: config.httpResponseType || 'json',\r\n            withCredentials: config.withCredentials || false,\r\n        }).pipe(catchError(err => {\r\n            // Do not use NGXLogger here because this could cause an infinite loop \r\n            console.error('NGXLogger: Failed to log on server', err);\r\n            return throwError(err);\r\n        })).subscribe();\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, deps: [{ token: i1.HttpBackend, optional: true }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerServerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerServerService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: i1.HttpBackend, decorators: [{\r\n                        type: Optional\r\n                    }] }];\r\n    } });\n\n/**\r\n * Injection token of logger writer service\r\n */\r\nconst TOKEN_LOGGER_WRITER_SERVICE = 'TOKEN_LOGGER_WRITER_SERVICE';\n\nvar NgxLoggerLevel;\r\n(function (NgxLoggerLevel) {\r\n    NgxLoggerLevel[NgxLoggerLevel[\"TRACE\"] = 0] = \"TRACE\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"DEBUG\"] = 1] = \"DEBUG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"INFO\"] = 2] = \"INFO\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"LOG\"] = 3] = \"LOG\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"WARN\"] = 4] = \"WARN\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"ERROR\"] = 5] = \"ERROR\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"FATAL\"] = 6] = \"FATAL\";\r\n    NgxLoggerLevel[NgxLoggerLevel[\"OFF\"] = 7] = \"OFF\";\r\n})(NgxLoggerLevel || (NgxLoggerLevel = {}));\n\nconst DEFAULT_COLOR_SCHEME = [\r\n    'purple',\r\n    'teal',\r\n    'gray',\r\n    'gray',\r\n    'red',\r\n    'red',\r\n    'red'\r\n];\n\nclass NGXLoggerWriterService {\r\n    constructor(platformId) {\r\n        this.platformId = platformId;\r\n        this.isIE = isPlatformBrowser(platformId) && navigator && navigator.userAgent &&\r\n            !!(navigator.userAgent.indexOf('MSIE') !== -1 || navigator.userAgent.match(/Trident\\//) || navigator.userAgent.match(/Edge\\//));\r\n        this.logFunc = this.isIE ? this.logIE.bind(this) : this.logModern.bind(this);\r\n    }\r\n    /** Generate a \"meta\" string that is displayed before the content sent to the log function */\r\n    prepareMetaString(metadata, config) {\r\n        const fileDetails = config.disableFileDetails === true ? '' : `[${metadata.fileName}:${metadata.lineNumber}:${metadata.columnNumber}]`;\r\n        return `${metadata.timestamp} ${NgxLoggerLevel[metadata.level]} ${fileDetails}`;\r\n    }\r\n    /** Get the color to use when writing to console */\r\n    getColor(metadata, config) {\r\n        var _a;\r\n        const configColorScheme = (_a = config.colorScheme) !== null && _a !== void 0 ? _a : DEFAULT_COLOR_SCHEME;\r\n        // this is needed to avoid a build error\r\n        if (metadata.level === NgxLoggerLevel.OFF) {\r\n            return undefined;\r\n        }\r\n        return configColorScheme[metadata.level];\r\n    }\r\n    /** Log to the console specifically for IE */\r\n    logIE(metadata, config, metaString) {\r\n        // Coloring doesn't work in IE\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`${metaString} `, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`${metaString} `, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Log to the console */\r\n    logModern(metadata, config, metaString) {\r\n        const color = this.getColor(metadata, config);\r\n        // make sure additional isn't null or undefined so that ...additional doesn't error\r\n        const additional = metadata.additional || [];\r\n        switch (metadata.level) {\r\n            case NgxLoggerLevel.WARN:\r\n                console.warn(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.ERROR:\r\n            case NgxLoggerLevel.FATAL:\r\n                console.error(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            case NgxLoggerLevel.INFO:\r\n                console.info(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            //  Disabling console.trace since the stack trace is not helpful. it is showing the stack trace of\r\n            // the console.trace statement\r\n            // case NgxLoggerLevel.TRACE:\r\n            //   console.trace(`%c${metaString}`, `color:${color}`, message, ...additional);\r\n            //   break;\r\n            case NgxLoggerLevel.DEBUG:\r\n                console.debug(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n                break;\r\n            default:\r\n                console.log(`%c${metaString}`, `color:${color}`, metadata.message, ...additional);\r\n        }\r\n    }\r\n    /** Write the content sent to the log function to the console */\r\n    writeMessage(metadata, config) {\r\n        const metaString = this.prepareMetaString(metadata, config);\r\n        this.logFunc(metadata, config, metaString);\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, deps: [{ token: PLATFORM_ID }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLoggerWriterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLoggerWriterService, decorators: [{\r\n            type: Injectable\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [PLATFORM_ID]\r\n                    }] }];\r\n    } });\n\nclass NGXLogger {\r\n    constructor(configEngine, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.configEngine = configEngine;\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n        // The config engine is provided with an inject token which means the user has all control on the scope of that instance\r\n        // By default each loggerService instance has its own configEngine (see example in \"not-a-singleton\" projects)\r\n        this.configEngine = configEngine;\r\n    }\r\n    /** Get a readonly access to the level configured for the NGXLogger */\r\n    get level() {\r\n        return this.configEngine.level;\r\n    }\r\n    /** Get a readonly access to the serverLogLevel configured for the NGXLogger */\r\n    get serverLogLevel() {\r\n        return this.configEngine.serverLogLevel;\r\n    }\r\n    trace(message, ...additional) {\r\n        this._log(NgxLoggerLevel.TRACE, message, additional);\r\n    }\r\n    debug(message, ...additional) {\r\n        this._log(NgxLoggerLevel.DEBUG, message, additional);\r\n    }\r\n    info(message, ...additional) {\r\n        this._log(NgxLoggerLevel.INFO, message, additional);\r\n    }\r\n    log(message, ...additional) {\r\n        this._log(NgxLoggerLevel.LOG, message, additional);\r\n    }\r\n    warn(message, ...additional) {\r\n        this._log(NgxLoggerLevel.WARN, message, additional);\r\n    }\r\n    error(message, ...additional) {\r\n        this._log(NgxLoggerLevel.ERROR, message, additional);\r\n    }\r\n    fatal(message, ...additional) {\r\n        this._log(NgxLoggerLevel.FATAL, message, additional);\r\n    }\r\n    /** @deprecated customHttpHeaders is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomHttpHeaders(headers) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpHeaders = headers;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated customHttpParams is now part of the config, this should be updated via @see updateConfig */\r\n    setCustomParams(params) {\r\n        const config = this.getConfigSnapshot();\r\n        config.customHttpParams = params;\r\n        this.updateConfig(config);\r\n    }\r\n    /** @deprecated withCredentials is now part of the config, this should be updated via @see updateConfig */\r\n    setWithCredentialsOptionValue(withCredentials) {\r\n        const config = this.getConfigSnapshot();\r\n        config.withCredentials = withCredentials;\r\n        this.updateConfig(config);\r\n    }\r\n    /**\r\n     * Register a INGXLoggerMonitor that will be trigger when a log is either written or sent to server\r\n     *\r\n     * There is only one monitor, registering one will overwrite the last one if there was one\r\n     * @param monitor\r\n     */\r\n    registerMonitor(monitor) {\r\n        this._loggerMonitor = monitor;\r\n    }\r\n    /** Set config of logger\r\n     *\r\n     * Warning : This overwrites all the config, if you want to update only one property, you should use @see getConfigSnapshot before\r\n     */\r\n    updateConfig(config) {\r\n        this.configEngine.updateConfig(config);\r\n    }\r\n    /** Get config of logger */\r\n    getConfigSnapshot() {\r\n        return this.configEngine.getConfig();\r\n    }\r\n    _log(level, message, additional = []) {\r\n        const config = this.configEngine.getConfig();\r\n        const shouldCallWriter = this.ruleService.shouldCallWriter(level, config, message, additional);\r\n        const shouldCallServer = this.ruleService.shouldCallServer(level, config, message, additional);\r\n        const shouldCallMonitor = this.ruleService.shouldCallMonitor(level, config, message, additional);\r\n        if (!shouldCallWriter && !shouldCallServer && !shouldCallMonitor) {\r\n            // If nothing is to be called we return\r\n            return;\r\n        }\r\n        const metadata = this.metadataService.getMetadata(level, config, message, additional);\r\n        this.mapperService.getLogPosition(config, metadata).pipe(take(1)).subscribe(logPosition => {\r\n            if (logPosition) {\r\n                metadata.fileName = logPosition.fileName;\r\n                metadata.lineNumber = logPosition.lineNumber;\r\n                metadata.columnNumber = logPosition.columnNumber;\r\n            }\r\n            if (shouldCallMonitor && this._loggerMonitor) {\r\n                this._loggerMonitor.onLog(metadata, config);\r\n            }\r\n            if (shouldCallWriter) {\r\n                this.writerService.writeMessage(metadata, config);\r\n            }\r\n            if (shouldCallServer) {\r\n                this.serverService.sendToServer(metadata, config);\r\n            }\r\n        });\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, deps: [{ token: TOKEN_LOGGER_CONFIG_ENGINE }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ NGXLogger.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: NGXLogger, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_CONFIG_ENGINE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                    }] }];\r\n    } });\n\n// Keeping this to avoid any breaking change for now, this class should be removed later\r\n/**\r\n * CustomNGXLoggerService is designed to allow users to get a new instance of a logger\r\n * @deprecated The logger is now fully customisable so this class is now useless\r\n */\r\nclass CustomNGXLoggerService {\r\n    constructor(configEngine, metadataService, ruleService, mapperService, writerService, serverService) {\r\n        this.configEngine = configEngine;\r\n        this.metadataService = metadataService;\r\n        this.ruleService = ruleService;\r\n        this.mapperService = mapperService;\r\n        this.writerService = writerService;\r\n        this.serverService = serverService;\r\n    }\r\n    /**\r\n     * Create an instance of a logger\r\n     * @deprecated The logger is now fully customisable so this function is now useless, if you want a specific instance of NGXLogger, either use the new keyword or Angular dependency injection\r\n     * @param config\r\n     * @param serverService\r\n     * @param logMonitor\r\n     * @param mapperService\r\n     * @returns\r\n     */\r\n    create(config, serverService, logMonitor, mapperService) {\r\n        this.configEngine.updateConfig(config);\r\n        const logger = new NGXLogger(this.configEngine, this.metadataService, this.ruleService, mapperService || this.mapperService, this.writerService, serverService || this.serverService);\r\n        if (logMonitor) {\r\n            logger.registerMonitor(logMonitor);\r\n        }\r\n        return logger;\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, deps: [{ token: TOKEN_LOGGER_CONFIG_ENGINE }, { token: TOKEN_LOGGER_METADATA_SERVICE }, { token: TOKEN_LOGGER_RULES_SERVICE }, { token: TOKEN_LOGGER_MAPPER_SERVICE }, { token: TOKEN_LOGGER_WRITER_SERVICE }, { token: TOKEN_LOGGER_SERVER_SERVICE }], target: i0.ɵɵFactoryTarget.Injectable });\r\n/** @nocollapse */ /** @nocollapse */ CustomNGXLoggerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, providedIn: 'root' });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: CustomNGXLoggerService, decorators: [{\r\n            type: Injectable,\r\n            args: [{\r\n                    providedIn: 'root'\r\n                }]\r\n        }], ctorParameters: function () {\r\n        return [{ type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_CONFIG_ENGINE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_METADATA_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_RULES_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_MAPPER_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_WRITER_SERVICE]\r\n                    }] }, { type: undefined, decorators: [{\r\n                        type: Inject,\r\n                        args: [TOKEN_LOGGER_SERVER_SERVICE]\r\n                    }] }];\r\n    } });\n\nclass LoggerModule {\r\n    static forRoot(config, customProvider) {\r\n        if (!customProvider) {\r\n            customProvider = {};\r\n        }\r\n        // default config provider\r\n        if (!customProvider.configProvider) {\r\n            customProvider.configProvider = { provide: TOKEN_LOGGER_CONFIG, useValue: config || {} };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.configProvider.provide !== TOKEN_LOGGER_CONFIG) {\r\n                throw new Error(`Wrong injection token for configProvider, it should be ${TOKEN_LOGGER_CONFIG} and you used ${customProvider.configProvider.provide}`);\r\n            }\r\n        }\r\n        // default configEngine provider\r\n        if (!customProvider.configEngineProvider) {\r\n            customProvider.configEngineProvider = { provide: TOKEN_LOGGER_CONFIG_ENGINE, useClass: NGXLoggerConfigEngine };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.configEngineProvider.provide !== TOKEN_LOGGER_CONFIG_ENGINE) {\r\n                throw new Error(`Wrong injection token for configEngineProvider, it should be '${TOKEN_LOGGER_CONFIG_ENGINE}' and you used '${customProvider.configEngineProvider.provide}'`);\r\n            }\r\n        }\r\n        // default metadata provider\r\n        if (!customProvider.metadataProvider) {\r\n            customProvider.metadataProvider = { provide: TOKEN_LOGGER_METADATA_SERVICE, useClass: NGXLoggerMetadataService };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.metadataProvider.provide !== TOKEN_LOGGER_METADATA_SERVICE) {\r\n                throw new Error(`Wrong injection token for metadataProvider, it should be '${TOKEN_LOGGER_METADATA_SERVICE}' and you used '${customProvider.metadataProvider.provide}'`);\r\n            }\r\n        }\r\n        // default rule provider\r\n        if (!customProvider.ruleProvider) {\r\n            customProvider.ruleProvider = { provide: TOKEN_LOGGER_RULES_SERVICE, useClass: NGXLoggerRulesService };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.ruleProvider.provide !== TOKEN_LOGGER_RULES_SERVICE) {\r\n                throw new Error(`Wrong injection token for ruleProvider, it should be '${TOKEN_LOGGER_RULES_SERVICE}' and you used '${customProvider.ruleProvider.provide}'`);\r\n            }\r\n        }\r\n        // default mapper provider\r\n        if (!customProvider.mapperProvider) {\r\n            customProvider.mapperProvider = { provide: TOKEN_LOGGER_MAPPER_SERVICE, useClass: NGXLoggerMapperService };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.mapperProvider.provide !== TOKEN_LOGGER_MAPPER_SERVICE) {\r\n                throw new Error(`Wrong injection token for mapperProvider, it should be '${TOKEN_LOGGER_MAPPER_SERVICE}' and you used '${customProvider.mapperProvider.provide}'`);\r\n            }\r\n        }\r\n        // default writer provider\r\n        if (!customProvider.writerProvider) {\r\n            customProvider.writerProvider = { provide: TOKEN_LOGGER_WRITER_SERVICE, useClass: NGXLoggerWriterService };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.writerProvider.provide !== TOKEN_LOGGER_WRITER_SERVICE) {\r\n                throw new Error(`Wrong injection token for writerProvider, it should be '${TOKEN_LOGGER_WRITER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        // default server provider\r\n        if (!customProvider.serverProvider) {\r\n            customProvider.serverProvider = { provide: TOKEN_LOGGER_SERVER_SERVICE, useClass: NGXLoggerServerService };\r\n        }\r\n        else {\r\n            // if the user provided its own config, we just make sure the injection token is correct\r\n            if (customProvider.serverProvider.provide !== TOKEN_LOGGER_SERVER_SERVICE) {\r\n                throw new Error(`Wrong injection token for serverProvider, it should be '${TOKEN_LOGGER_SERVER_SERVICE}' and you used '${customProvider.writerProvider.provide}'`);\r\n            }\r\n        }\r\n        return {\r\n            ngModule: LoggerModule,\r\n            providers: [\r\n                NGXLogger,\r\n                customProvider.configProvider,\r\n                customProvider.configEngineProvider,\r\n                customProvider.metadataProvider,\r\n                customProvider.ruleProvider,\r\n                customProvider.mapperProvider,\r\n                customProvider.writerProvider,\r\n                customProvider.serverProvider,\r\n                CustomNGXLoggerService,\r\n            ]\r\n        };\r\n    }\r\n    static forChild() {\r\n        // todo : this forChild is useless for now because nothing is different from forRoot.\r\n        // This should be implemented so that user can change the providers in the forChild\r\n        return {\r\n            ngModule: LoggerModule,\r\n        };\r\n    }\r\n}\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, imports: [CommonModule] });\r\n/** @nocollapse */ /** @nocollapse */ LoggerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, providers: [\r\n        DatePipe // DatePipe is required by metadata-service.ts\r\n    ], imports: [[\r\n            CommonModule\r\n        ]] });\r\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: LoggerModule, decorators: [{\r\n            type: NgModule,\r\n            args: [{\r\n                    imports: [\r\n                        CommonModule\r\n                    ],\r\n                    providers: [\r\n                        DatePipe // DatePipe is required by metadata-service.ts\r\n                    ]\r\n                }]\r\n        }] });\n\n/*\r\n * Public API Surface of ngx-logger\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { CustomNGXLoggerService, DEFAULT_COLOR_SCHEME, LoggerModule, NGXLogger, NGXLoggerConfigEngine, NGXLoggerMapperService, NGXLoggerMetadataService, NGXLoggerMonitor, NGXLoggerRulesService, NGXLoggerServerService, NGXLoggerWriterService, NgxLoggerLevel, TOKEN_LOGGER_CONFIG, TOKEN_LOGGER_CONFIG_ENGINE, TOKEN_LOGGER_MAPPER_SERVICE, TOKEN_LOGGER_METADATA_SERVICE, TOKEN_LOGGER_RULES_SERVICE, TOKEN_LOGGER_SERVER_SERVICE, TOKEN_LOGGER_WRITER_SERVICE };\n"]},"metadata":{},"sourceType":"module"}